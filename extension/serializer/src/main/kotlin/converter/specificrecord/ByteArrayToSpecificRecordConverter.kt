package io.holixon.axon.avro.serializer.converter.specificrecord

import io.holixon.axon.avro.schema.api.AxonAvroSchemaRegistry
import io.holixon.axon.avro.serializer.AxonAvroExtension.MAGIC_BYTE
import io.holixon.extensions.kotlin.serialization.AbstractContentTypeConverter
import org.apache.avro.specific.SpecificRecordBase
import org.axonframework.serialization.SerializationException
import java.nio.ByteBuffer
import kotlin.reflect.KClass

class ByteArrayToSpecificRecordConverter(
  val schemaRegistry: AxonAvroSchemaRegistry
) : AbstractContentTypeConverter<ByteArray, SpecificRecordBase>(ByteArray::class, SpecificRecordBase::class) {
  companion object {

    /**
     * Converts the given ByteArray payload to a ByteBuffer while checking if it is a valid arvo singleObject encoded payload.
     */
    fun byteBuffer(payload: ByteArray): ByteBuffer {
      val buffer = ByteBuffer.wrap(payload)
      if (buffer.get() != MAGIC_BYTE.toByte()) {
        throw SerializationException("Unknown magic byte!")
      }
      return buffer
    }
  }

  override fun convert(original: ByteArray): SpecificRecordBase {
    // wrap in buffer and remove magicByte
    val buffer = byteBuffer(original)

    // read the writerSchemaId from buffer
    val writerSchemaId = buffer.long

    // load the writerSchema from the registry
    val writerSchema = schemaRegistry.findById(writerSchemaId).orElseThrow { SerializationException("Cannot read writerSchema with id=$writerSchemaId") }

    // we have to assume that the namespace and name of the message payload did not change, so we try to load the class based on the canonical name
    // of the writer schema. This might lead to another (earlier or later) revision, but the canonical name should not have changed.
    @Suppress("UNCHECKED_CAST")
    val targetClass: Class<SpecificRecordBase> = Class.forName(writerSchema.canonicalName) as Class<SpecificRecordBase>

    // then we use reflection to call the decoder function generated by avro and return the result
    return targetClass.getDeclaredMethod("fromByteBuffer", ByteBuffer::class.java)
      .invoke(null, buffer) as SpecificRecordBase
  }
}
