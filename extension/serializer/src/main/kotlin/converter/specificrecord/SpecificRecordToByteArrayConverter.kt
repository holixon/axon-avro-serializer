package io.holixon.axon.avro.serializer.converter.specificrecord

import io.holixon.axon.avro.schema.api.AxonAvroSchemaRegistry
import io.holixon.axon.avro.serializer.AxonAvroExtension
import io.holixon.extensions.kotlin.serialization.AbstractContentTypeConverter
import org.apache.avro.specific.SpecificRecordBase
import java.io.ByteArrayOutputStream
import java.nio.ByteBuffer
import java.nio.channels.Channels

class SpecificRecordToByteArrayConverter(
  val schemaRegistry: AxonAvroSchemaRegistry
) : AbstractContentTypeConverter<SpecificRecordBase, ByteArray>(SpecificRecordBase::class, ByteArray::class) {
  companion object {
    // encoding schemaId as 8 bit Long
    val idSize = 8
  }

  override fun convert(original: SpecificRecordBase): ByteArray {
    // lookup the record schema, if not present, register
    // TODO: this behavior should be configurable ... do we want auto registration for the first message of a given type?
    val writerSchemaId = schemaRegistry.findByInfoOrRegister(original.schemaInfo(), original.schema).globalId

    // use the automatic binary encoding of the record class generated by avro
    val buf = original.toByteBuffer()

    // according to singleObject spec, we write:
    // - a magicByte to identify this byteArray as valid arvo singleObject
    val out = ByteArrayOutputStream()
    out.write(AxonAvroExtension.MAGIC_BYTE)

    // and the writer schema Id, as an 8 bit long
    // TODO: apicurio uses an interface to abstract from this constant, seams that older versions of apicurio used only 4 bits which will break the decoding.
    out.write(ByteBuffer.allocate(idSize).putLong(writerSchemaId).array())

    // some java nio hack to write the buffer to the stream ... c&p from stackoverflow. Seams to work.
    Channels.newChannel(out).write(buf)

    // done
    return out.toByteArray()
  }

}
