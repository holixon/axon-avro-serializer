package io.holixon.axon.avro.serializer.converter

import io.holixon.axon.avro.common.AvroSchemaRegistry
import io.holixon.axon.avro.common.ext.AvroSchemaRegistryExt.schemaResolver
import io.holixon.axon.avro.common.darwin.DarwinSingleObjectDecoder
import io.holixon.axon.avro.common.ext.SpecificRecordBaseExt.fromByteArray
import io.holixon.axon.avro.common.ext.SpecificRecordBaseExt.toByteArray
import io.holixon.extensions.kotlin.AxonAvroKotlinExtensions.contentTypeConverter
import org.apache.avro.specific.SpecificRecordBase
import org.axonframework.serialization.ContentTypeConverter

class SpecificRecordConverter(
  schemaRegistry: AvroSchemaRegistry
) {

  private val decoder = DarwinSingleObjectDecoder(schemaRegistry.schemaResolver())

  val specificRecordToByteArrayConverter: ContentTypeConverter<SpecificRecordBase, ByteArray> = contentTypeConverter { toByteArray(it) }
  val byteArrayToSpecificRecordConverter: ContentTypeConverter<ByteArray, SpecificRecordBase> = contentTypeConverter { fromByteArray(it) }

  fun toByteArray(data: SpecificRecordBase): ByteArray = data.toByteArray()

  fun fromByteArray(data: ByteArray): SpecificRecordBase {
    // load the writerSchema from the registry
    val writerSchema = decoder.apply(data).schema

    // we have to assume that the namespace and name of the message payload did not change, so we try to load the class based on the canonical name
    // of the writer schema. This might lead to another (earlier or later) revision, but the canonical name should not have changed.
    @Suppress("UNCHECKED_CAST")
    val targetClass: Class<SpecificRecordBase> = Class.forName(writerSchema.canonicalName) as Class<SpecificRecordBase>

    // then we use reflection to call the decoder function generated by avro and return the result
    return targetClass.fromByteArray(data)
  }

}
